/*
-----------------------------------------------------------------------------
Filename:    OgreApp2.cpp
-----------------------------------------------------------------------------


This source file is generated by the
___                   _              __    __ _                  _ 
/___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
//  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
|___/                 |_|   |_|                                 
Ogre 1.8.x Application Wizard for VC10 (May 2012)
https://bitbucket.org/jacmoe/ogreappwizards
-----------------------------------------------------------------------------
*/
#include <OgreSceneQuery.h>
#include "OgreApp2.h"
#include "OgreMaxScene.hpp"

//-------------------------------------------------------------------------------------
OgreApp2::OgreApp2(void)
{
}
//-------------------------------------------------------------------------------------
OgreApp2::~OgreApp2(void)
{
}

//-------------------------------------------------------------------------------------
void OgreApp2::createScene(void)
{
	OgreMax::OgreMaxScene * maxScene= new OgreMax::OgreMaxScene();
	maxScene->Load("Scene.scene",this->mWindow, OgreMax::OgreMaxScene::NO_OPTIONS,mSceneMgr,0,0);
	setupPlayerContent();
	mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));

	// Create a light
	Ogre::Light* l = mSceneMgr->createLight("MainLight");

	Ogre::OverlayManager& overlayManager = Ogre::OverlayManager::getSingleton();
	// Create an overlay
	//Ogre::Overlay* overlay = overlayManager.getByName("MyOverlays/AnotherOverlay");
	Ogre::Overlay* overlay = overlayManager.getByName("MyOverlays/MainOverlay");

	overlay->show();
	/*	mCamera->setPosition(Ogre::Vector3(60,70,60));
	l->setPosition(20,80,50);
	//mCamera->lookAt(tigerNode->getPosition());*/

}

void OgreApp2::setupPlayerContent()
{
	// set shadow properties
	mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
	mSceneMgr->setShadowColour(ColourValue(0.5, 0.5, 0.5));
	mSceneMgr->setShadowTextureSize(1024);
	mSceneMgr->setShadowTextureCount(1);


	// disable default camera control so the character can do its own
	mCameraMan->setStyle(OgreBites::CS_MANUAL);
	mSceneMgr->setAmbientLight(ColourValue(0.9, 0.9, 0.9));



	Ogre::Light* pointLight = mSceneMgr->createLight("pointLight");
	pointLight->setType(Ogre::Light::LT_POINT);
	pointLight->setPosition(Ogre::Vector3(0, 150, 250));

	pointLight->setDiffuseColour(0.0, 0.0, 0.0);
	pointLight->setSpecularColour(0.0, 0.0, 0.0);

	mPlayer = new PlayerCharacterController(mCamera);
	mMonster = new MonsterCharacterController(mSceneMgr);

}

void OgreApp2::cleanupPlayerContent()
{
	// clean up character controller and the floor mesh
	if (mPlayer)
	{
		delete mPlayer;
		mPlayer = 0;
	}
	if (mMonster)
	{
		delete mMonster;
		mMonster = 0;
	}
	//MeshManager::getSingleton().remove("floor");
}
bool OgreApp2:: frameRenderingQueued(const Ogre::FrameEvent& evt )
{
	BaseApplication::frameRenderingQueued(evt);
	if(mWindow->isClosed()) return false;
	if(mShutDown) return false; //关闭窗口
	mKeyboard->capture();
	mMouse->capture();
	//mAnimationState->addTime(evt.timeSinceLastFrame);
	//mAnimationState1->addTime(evt.timeSinceLastFrame);
	this->mMonster->AI(mPlayer->getCurrentAction());
	if(mKeyboard->isKeyDown(OIS::KC_ESCAPE)) 
		return false;
	if(mKeyboard->isKeyDown(OIS::KC_LSHIFT)) mPlayer->setRun(true);
	else mPlayer->setRun(false);
	mPlayer->addTime(evt.timeSinceLastFrame);
	mMonster->addTime(evt.timeSinceLastFrame);


	//Ogre::query
	//Entity * cylinderEnt = mSceneMgr->getEntity("Cylinder01");
	//Ogre::AxisAlignedBox cbox = cylinderEnt->getWorldBoundingBox();
	//if(!cbox.contains(pbox))
	//{
	//	//mPlayer->setInfo("ddd");
	//}
	////创建相交检测
	// IntersectionSceneQuery* pISQuery=mSceneMgr->createIntersectionQuery();
	// //执行查询
	// IntersectionSceneQueryResult QResult=pISQuery->execute();
	// //遍历查询列表找出两个相交的物体
	// for (SceneQueryMovableIntersectionList::iterator iter = QResult.movables2movables.begin();
	//  iter != QResult.movables2movables.end();++iter)
	// {
	// 
	//  SceneQueryMovableObjectPair pObject=static_cast<SceneQueryMovableObjectPair>(*iter);
	//  //if(pObject)
	//  {
	//   String strFirst=pObject.first->getName();
	//   String strSecond=pObject.second->getName();
	//   //下面加入你自己的两个物体相交判断代码，或者简单的用AABB的判断方法，
	//  }
	// }


	SphereSceneQuery * pQuery=mSceneMgr->createSphereQuery(Sphere(Vector3(0,0,0),210));
	SceneQueryResult QResult=pQuery->execute();
	Entity* ent;
	int sign = 0;
	for (SceneQueryResultMovableList::iterator iter = QResult.movables.begin(); iter != QResult.movables.end();++iter)
	{
		MovableObject* pObject=static_cast<MovableObject*>(*iter);
		if(pObject)
		{
			if(pObject->getMovableType()=="Entity")
			{
				ent = static_cast<Entity*>(pObject);
				if(ent->getName()=="PlayerBody")
				{
					//mPlayer->setInfo("IN!!");
					sign = 1;
					break;
				}
				else
				{
					//mPlayer->stopAnim();
					//mPlayer->setInfo("OUT!!");
				}
			}
		}

	}
	if(sign != 1)
		mPlayer->stopAnim();
	//bool playerdead = mPlayer->ifdead();
	//bool monsterdead = mMonster->ifdead();
	//if(playerdead||monsterdead)
	//{
	//	//mPlayer->addTime(0);
	//	//mPlayer->updateAnimations(0);
	//	//mPlayer->updateBody(0);
	//	return true;
	//}
	Ogre::AxisAlignedBox pbox = mPlayer->getAABB();
	Ogre::AxisAlignedBox mbox = mMonster->getAABB();




	if(pbox.intersects(mbox))
	{
		String str_p = "Player\n" ;
		String str_m = "Monster\n";
		String hurt_p = "-";
		String hurt_m = "-";
		std::string str_hpp;
		std::string str_hpm;
		std::string str_hurtp;
		std::string str_hurtm;
		std::stringstream ss;
		int hpp_now = mPlayer->getHP();
		int hpm_now = mMonster->getHP();     
		int attack_player = mPlayer->getAttack();//rand() % (hpp_now); 
		int attack_monster = mMonster->getAttack();//rand() % (hpm_now);
		if(attack_player > 0 || attack_monster > 0)
		{
			ss<<attack_player;
			ss>>str_hurtp;
			ss.clear();
			ss<<attack_monster;
			ss>>str_hurtm;
			ss.clear();
			str_hurtm = "-" + str_hurtm;
			str_hurtp = "-" + str_hurtp;
			if(attack_monster > 0)
				mPlayer->setHurtInfo(str_hurtm);
			if(attack_player > 0)
				mMonster->setHurtInfo(str_hurtp);
		}
		int hpp = hpp_now - attack_monster;
		int hpm = hpm_now - attack_player;
		hpp = hpp > 0? hpp: 0;
		hpm = hpm > 0? hpm: 0;
		mPlayer->setHP(hpp);
		mMonster->setHP(hpm);
		OverlayElement* hpp_ele = Ogre::OverlayManager::getSingleton().getOverlayElement("MyGuiElements/playerHP");
		OverlayElement* hpm_ele = Ogre::OverlayManager::getSingleton().getOverlayElement("MyGuiElements/monsterHP");
		Real wid_p = 0.2 * hpp / 1500;
		Real wid_m = 0.2 * hpm / 2000;
		hpp_ele->setWidth(wid_p);
		hpm_ele->setWidth(wid_m);
		ss<<hpp;
		ss>>str_hpp;
		ss.clear();
		ss<<hpm;
		ss>>str_hpm;
		ss.clear();
		str_p += str_hpp;
		str_m += str_hpm;
		str_p += "/1500";
		str_m += "/2000";
		mPlayer->setInfo(str_p);
		mMonster->setInfo(str_m);


	}
	else
	{
		mMonster->setHurtInfo("HP");
		mPlayer->setHurtInfo("HP");
	}
	return true;
}
bool OgreApp2:: keyPressed( const OIS::KeyEvent& evt )
{
	if (!mTrayMgr->isDialogVisible()) {
		//mMonster->injectKeyDown(evt);
		mPlayer->injectKeyDown(evt);
	}

	return true;
}

bool OgreApp2:: keyReleased( const OIS::KeyEvent& evt )
{
	if (!mTrayMgr->isDialogVisible()){
		//mMonster->injectKeyDown(evt);  
		mPlayer->injectKeyUp(evt);
	}
	return BaseApplication::keyReleased(evt);

}
// OIS::MouseListener
bool OgreApp2:: mouseMoved( const OIS::MouseEvent& evt )
{
	if (!mTrayMgr->isDialogVisible()) {
		//mMonster->injectMouseMove(evt);
		mPlayer->injectMouseMove(evt);
	}
	return BaseApplication::mouseMoved(evt);
}
bool OgreApp2:: mousePressed( const OIS::MouseEvent& evt, OIS::MouseButtonID id )
{
	if (!mTrayMgr->isDialogVisible()) {
		//mMonster->injectMouseDown(evt,id);
		mPlayer->injectMouseDown(evt, id);
	}
	return BaseApplication::mousePressed(evt, id);
}
bool OgreApp2:: mouseReleased( const OIS::MouseEvent& evt, OIS::MouseButtonID id )
{
	BaseApplication::mouseReleased(evt,id);
	return true;
}


#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
	INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
	int main(int argc, char *argv[])
#endif
	{
		// Create application object
		OgreApp2 app;

		try {
			app.go();
		} catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
			MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
			std::cerr << "An exception has occured: " <<
				e.getFullDescription().c_str() << std::endl;
#endif
		}

		return 0;
	}

#ifdef __cplusplus
}
#endif
